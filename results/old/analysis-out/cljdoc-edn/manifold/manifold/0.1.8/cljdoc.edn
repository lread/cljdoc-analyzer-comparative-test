{:group-id "manifold", :artifact-id "manifold", :version "0.1.8", :codox {"clj" [{:author "Zach Tellman", :doc "Methods for creating, transforming, and interacting with asynchronous streams of values.\n", :name manifold.stream, :publics ({:name ->sink, :file "manifold/stream.clj", :line 62, :arglists ([x] [x default-val]), :doc "Converts, if possible, the object to a Manifold sink, or `default-val` if it cannot.  If no\ndefault value is given, an `IllegalArgumentException` is thrown.", :type :var, :members ()} {:name ->source, :file "manifold/stream.clj", :line 78, :arglists ([x] [x default-val]), :doc "Converts, if possible, the object to a Manifold source, or `default-val` if it cannot.  If no\ndefault value is given, an `IllegalArgumentException` is thrown.", :type :var, :members ()} {:name batch, :file "manifold/stream.clj", :line 999, :arglists ([batch-size s] [max-size max-latency s] [metric max-size max-latency s]), :doc "Batches messages, either into groups of fixed size, or according to upper bounds on size and\nlatency, in milliseconds.  By default, each message is of size `1`, but a custom `metric` function that\nreturns the size of each message may be defined.", :type :var, :members ()} {:name buffer, :file "manifold/stream.clj", :line 986, :arglists ([limit s] [metric limit s]), :doc "Takes a stream, and returns a stream which is a buffered view of that stream.  The buffer\nsize may either be measured in messages, or if a `metric` is defined, by the sum of `metric`\nmapped over all messages currently buffered.", :type :var, :members ()} {:name buffered-stream, :file "manifold/stream.clj", :line 952, :arglists ([buffer-size] [metric limit] [metric limit description]), :doc "A stream which will buffer at most `limit` data, where the size of each message\nis defined by `(metric message)`.", :type :var, :members ()} {:name close!, :file "manifold/stream.clj", :line 199, :arglists ([sink]), :doc "Closes a source or sink, so that it can't emit or accept any more messages.\n", :type :var, :members ()} {:name closed?, :file "manifold/stream.clj", :line 204, :arglists ([sink]), :doc "Returns true if the event sink is closed.\n", :type :var, :members ()} {:name concat, :file "manifold/stream.clj", :line 799, :arglists ([s]), :doc "Takes a stream of streams, and flattens it into a single stream.\n", :type :var, :members ()} {:name connect, :file "manifold/stream.clj", :line 300, :arglists [[source sink] [source sink {:keys [upstream? downstream? timeout description], :or {upstream? false, downstream? true}}]], :doc "Connects a source to a sink, propagating all messages from the former into the latter.\n\nOptionally takes a map of parameters:\n\n|:---|:---\n| `upstream?` | if closing the sink should always close the source, even if there are other sinks downstream of the source.  Defaults to `false`.  Note that if the sink is the only thing downstream of the source, the source will always be closed, unless it is permanent.\n| `downstream?` | if closing the source will close the sink.  Defaults to `true`.\n| `timeout` | if defined, the maximum time, in milliseconds, that will be spent trying to put a message into the sink before closing it.  Useful when there are multiple sinks downstream of a source, and you want to avoid a single backed up sink from blocking all the others.\n| `description` | describes the connection, useful for traversing the stream topology via `downstream`.", :type :var, :members ()} {:name connect-via, :file "manifold/stream.clj", :line 500, :arglists ([src callback dst] [src callback dst options]), :doc "Feeds all messages from `src` into `callback`, with the understanding that they will\neventually be propagated into `dst` in some form.  The return value of `callback`\nshould be a deferred yielding either `true` or `false`. When `false`,  the downstream\nsink is assumed to be closed, and the connection is severed.\n\nReturns a deferred which yields `true` when `src` is exhausted or `callback` yields `false`.", :type :var, :members ()} {:name consume, :file "manifold/stream.clj", :line 473, :arglists ([callback source]), :doc "Feeds all messages from `source` into `callback`.\n\nMessages will be processed as quickly as the callback can be executed. Returns\na deferred which yields `true` when `source` is exhausted.", :type :var, :members ()} {:name consume-async, :file "manifold/stream.clj", :line 483, :arglists ([callback source]), :doc "Feeds all messages from `source` into `callback`, which must return a deferred yielding\n`true` or `false`.  If the returned value yields `false`, the consumption will be cancelled.\n\nMessages will be processed only as quickly as the deferred values are realized. Returns a\ndeferred which yields `true` when `source` is exhausted or `callback` yields `false`.", :type :var, :members ()} {:name description, :file "manifold/stream.clj", :line 176, :arglists ([x]), :doc "Returns a description of the stream.\n", :type :var, :members ()} {:name downstream, :file "manifold/stream.clj", :line 181, :arglists ([x]), :doc "Returns all sinks downstream of the given source as a sequence of 2-tuples, with the\nfirst element containing the connection's description, and the second element containing\nthe sink.", :type :var, :members ()} {:name drain-into, :file "manifold/stream.clj", :line 537, :arglists ([src dst]), :doc "Takes all messages from `src` and puts them into `dst`, and returns a deferred that\nyields `true` once `src` is drained or `dst` is closed.  If `src` is closed or drained,\n`dst` will not be closed.", :type :var, :members ()} {:name drained?, :file "manifold/stream.clj", :line 214, :arglists ([source]), :doc "Returns true if the event source is drained.\n", :type :var, :members ()} {:name filter, :file "manifold/stream.clj", :line 673, :arglists ([pred s]), :doc "Equivalent to Clojure's `filter`, but for streams instead of sequences.\n", :type :var, :members ()} {:name lazily-partition-by, :file "manifold/stream.clj", :line 760, :arglists ([f s]), :doc "Equivalent to Clojure's `partition-by`, but returns a stream of streams.  This means that\nif a sub-stream is not completely consumed, the next sub-stream will never be emitted.\n\nUse with caution.  If you're not totally sure you want a stream of streams, use\n`(transform (partition-by f))` instead.", :type :var, :members ()} {:name map, :file "manifold/stream.clj", :line 614, :arglists ([f s] [f s & rest]), :doc "Equivalent to Clojure's `map`, but for streams instead of sequences.\n", :type :var, :members ()} {:name mapcat, :file "manifold/stream.clj", :line 742, :arglists ([f s] [f s & rest]), :doc "Equivalent to Clojure's `mapcat`, but for streams instead of sequences.\n", :type :var, :members ()} {:name on-closed, :file "manifold/stream.clj", :line 209, :arglists ([sink callback]), :doc "Registers a no-arg callback which is invoked when the sink is closed.\n", :type :var, :members ()} {:name on-drained, :file "manifold/stream.clj", :line 219, :arglists ([source callback]), :doc "Registers a no-arg callback which is invoked when the source is drained.\n", :type :var, :members ()} {:name onto, :file "manifold/stream.clj", :line 153, :arglists ([executor s]), :doc "Returns an identical stream whose deferred callbacks will be executed\non `executor`.", :type :var, :members ()} {:name periodically, :file "manifold/stream.clj", :line 593, :arglists ([period initial-delay f] [period f]), :doc "Creates a stream which emits the result of invoking `(f)` every `period` milliseconds.\n", :type :var, :members ()} {:name put!, :file "manifold/stream.clj", :line 224, :arglists ([sink x]), :doc "Puts a value into a sink, returning a deferred that yields `true` if it succeeds,\nand `false` if it fails.  Guaranteed to be non-blocking.", :type :var, :members ()} {:name put-all!, :file "manifold/stream.clj", :line 232, :arglists ([sink msgs]), :doc "Puts all values into the sink, returning a deferred that yields `true` if all puts\nare successful, or `false` otherwise.  If the sink provides backpressure, will\npause. Guaranteed to be non-blocking.", :type :var, :members ()} {:name realize-each, :file "manifold/stream.clj", :line 628, :arglists ([s]), :doc "Takes a stream of potentially deferred values, and returns a stream of realized values.\n", :type :var, :members ()} {:name reduce, :file "manifold/stream.clj", :line 717, :arglists ([f s] [f initial-value s]), :doc "Equivalent to Clojure's `reduce`, but returns a deferred representing the return value.\n\nThe deferred will be realized once the stream is closed or if the accumulator\nfunctions returns a `reduced` value.", :type :var, :members ()} {:name reductions, :file "manifold/stream.clj", :line 686, :arglists ([f s] [f initial-value s]), :doc "Equivalent to Clojure's `reductions`, but for streams instead of sequences.\n", :type :var, :members ()} {:name sink-only, :file "manifold/stream.clj", :line 148, :arglists ([s]), :doc "Returns a view of the stream which is only a sink.\n", :type :var, :members ()} {:name sink?, :file "manifold/stream.clj", :line 171, :arglists ([x]), :doc "Returns true if the object is a Manifold sink.\n", :type :var, :members ()} {:name sinkable?, :file "manifold/stream.clj", :line 51, :arglists ([x]), :type :var, :members ()} {:name source-only, :file "manifold/stream.clj", :line 143, :arglists ([s]), :doc "Returns a view of the stream which is only a source.\n", :type :var, :members ()} {:name source?, :file "manifold/stream.clj", :line 166, :arglists ([x]), :doc "Returns true if the object is a Manifold source.\n", :type :var, :members ()} {:name sourceable?, :file "manifold/stream.clj", :line 57, :arglists ([x]), :type :var, :members ()} {:name splice, :file "manifold/stream.clj", :line 423, :arglists ([sink source]), :doc "Splices together two halves of a stream, such that all messages enqueued via `put!` go\ninto `sink`, and all messages dequeued via `take!` come from `source`.", :type :var, :members ()} {:name stream, :file "manifold/stream.clj", :line 335, :arglists ([] [buffer-size] [buffer-size xform] [buffer-size xform executor]), :doc "Returns a Manifold stream with a configurable `buffer-size`.  If a capacity is specified,\n`put!` will yield `true` when the message is in the buffer.  Otherwise it will only yield\n`true` once it has been consumed.\n\n`xform` is an optional transducer, which will transform all messages that are enqueued\nvia `put!` before they are dequeued via `take!`.\n\n`executor`, if defined, specifies which java.util.concurrent.Executor will be used to\nhandle the deferreds returned by `put!` and `take!`.", :type :var, :members ()} {:name stream*, :file "manifold/stream.clj", :line 354, :arglists [[{:keys [permanent? buffer-size description executor xform]}]], :doc "An alternate way to build a stream, via a map of parameters.\n\n|:---|:---\n| `permanent?` | if `true`, the channel cannot be closed\n| `buffer-size` | the number of messages that can accumulate in the channel before backpressure is applied\n| `description` | the description of the channel, which is a single arg function that takes the base properties and returns an enriched map.\n| `executor` | the `java.util.concurrent.Executor` that will execute all callbacks registered on the deferreds returns by `put!` and `take!`\n| `xform` | a transducer which will transform all messages that are enqueued via `put!` before they are dequeued via `take!`.", :type :var, :members ()} {:name stream->seq, :file "manifold/stream.clj", :line 552, :arglists ([s] [s timeout-interval]), :doc "Transforms a stream into a lazy sequence.  If a `timeout-interval` is defined, the sequence\nwill terminate if `timeout-interval` milliseconds elapses without a new event.", :type :var, :members ()} {:name stream?, :file "manifold/stream.clj", :line 161, :arglists ([x]), :doc "Returns true if the object is a Manifold stream.\n", :type :var, :members ()} {:name synchronous?, :file "manifold/stream.clj", :line 193, :arglists ([x]), :doc "Returns true if the underlying abstraction behaves synchronously, using thread blocking\nto provide backpressure.", :type :var, :members ()} {:name take!, :file "manifold/stream.clj", :line 263, :arglists ([source] [source default-val]), :doc "Takes a value from a stream, returning a deferred that yields the value when it\nis available, or `nil` if the take fails.  Guaranteed to be non-blocking.\n\nA special `default-val` may be specified, if it is important to differentiate\nbetween actual `nil` values and failures.", :type :var, :members ()} {:name throttle, :file "manifold/stream.clj", :line 1066, :arglists ([max-rate s] [max-rate max-backlog s]), :doc "Limits the `max-rate` that messages are emitted, per second.\n\nThe `max-backlog` dictates how much \"memory\" the throttling mechanism has, or how many\nmessages it will emit immediately after a long interval without any messages.  By default,\nthis is set to one second's worth.", :type :var, :members ()} {:name transform, :file "manifold/stream.clj", :line 604, :arglists ([xform s] [xform buffer-size s]), :doc "Takes a transducer `xform` and returns a source which applies it to source `s`. A buffer-size\nmay optionally be defined for the output source.", :type :var, :members ()} {:name try-put!, :file "manifold/stream.clj", :line 246, :arglists ([sink x timeout] [sink x timeout timeout-val]), :doc "Puts a value into a stream if the put can successfully be completed in `timeout`\nmilliseconds.  Returns a promiise that yields `true` if it succeeds, and `false`\nif it fails or times out.  Guaranteed to be non-blocking.\n\nA special `timeout-val` may be specified, if it is important to differentiate\nbetween failure due to timeout and other failures.", :type :var, :members ()} {:name try-take!, :file "manifold/stream.clj", :line 279, :arglists ([source timeout] [source default-val timeout timeout-val]), :doc "Takes a value from a stream, returning a deferred that yields the value if it is\navailable within `timeout` milliseconds, or `nil` if it fails or times out.\nGuaranteed to be non-blocking.\n\nSpecial `timeout-val` and `default-val` values may be specified, if it is\nimportant to differentiate between actual `nil` values and failures.", :type :var, :members ()} {:name weak-handle, :file "manifold/stream.clj", :line 188, :arglists ([x]), :doc "Returns a weak reference that can be used to construct topologies of streams.\n", :type :var, :members ()} {:name zip, :file "manifold/stream.clj", :line 645, :arglists ([a] [a & rest]), :doc "Takes n-many streams, and returns a single stream which will emit n-tuples representing\na message from each stream.", :type :var, :members ()})} {:name manifold.executor, :publics ({:name execute-pool, :file "manifold/executor.clj", :line 232, :arglists ([]), :type :var, :members ()} {:name executor, :file "manifold/executor.clj", :line 24, :arglists ([]), :type :var, :members ()} {:name executor-thread-local, :file "manifold/executor.clj", :line 22, :type :var, :members ()} {:name fixed-thread-executor, :file "manifold/executor.clj", :line 144, :arglists ([num-threads] [num-threads options]), :doc "Returns an executor which has a fixed number of threads.\n", :type :var, :members ()} {:name instrumented-executor, :file "manifold/executor.clj", :line 79, :arglists ([{:keys [thread-factory queue-length stats-callback sample-period control-period controller metrics initial-thread-count onto?], :or {initial-thread-count 1, sample-period 25, control-period 10000, metrics (EnumSet/allOf Stats$Metric), onto? true}}]), :doc "Returns a `java.util.concurrent.ExecutorService`, using [Dirigiste](https://github.com/ztellman/dirigiste).\n\n|:---|:----\n| `thread-factory` | an optional `java.util.concurrent.ThreadFactory` that creates the executor's threads. |\n| `queue-length` | the maximum number of pending tasks before `.execute()` begins throwing `java.util.concurrent.RejectedExecutionException`, defaults to `0`.\n| `stats-callback` | a function that will be invoked every `control-period` with the relevant statistics for the executor.\n| `sample-period` | the interval, in milliseconds, between sampling the state of the executor for resizing and gathering statistics, defaults to `25`.\n| `control-period` | the interval, in milliseconds, between use of the controller to adjust the size of the executor, defaults to `10000`.\n| `controller` | the Dirigiste controller that is used to guide the pool's size.\n| `metrics` | an `EnumSet` of the metrics that should be gathered for the controller, defaults to all.\n| `initial-thread-count` | the number of threads that the pool should begin with.\n| `onto?` | if true, all streams and deferred generated in the scope of this executor will also be 'on' this executor.", :type :var, :members ()} {:name register-execute-pool-stats-callback, :file "manifold/executor.clj", :line 209, :arglists ([c]), :doc "Registers a callback which will be called with execute-pool stats.\n", :type :var, :members ()} {:name register-wait-pool-stats-callback, :file "manifold/executor.clj", :line 179, :arglists ([c]), :doc "Registers a callback which will be called with wait-pool stats.\n", :type :var, :members ()} {:name stats->map, :file "manifold/executor.clj", :line 53, :arglists ([s] [s quantiles]), :doc "Converts a Dirigiste `Stats` object into a map of values onto quantiles.\n", :type :var, :members ()} {:name thread-factory, :file "manifold/executor.clj", :line 35, :arglists ([name-generator executor-promise] [name-generator executor-promise stack-size]), :type :var, :members ()} {:name unregister-execute-pool-stats-callback, :file "manifold/executor.clj", :line 214, :arglists ([c]), :doc "Unregisters a previous execute-pool stats callback.\n", :type :var, :members ()} {:name unregister-wait-pool-stats-callback, :file "manifold/executor.clj", :line 184, :arglists ([c]), :doc "Unregisters a previous wait-pool stats callback.\n", :type :var, :members ()} {:name utilization-executor, :file "manifold/executor.clj", :line 160, :arglists ([utilization] [utilization max-threads] [utilization max-threads options]), :doc "Returns an executor which sizes the thread pool according to target utilization, within\n`[0,1]`, up to `max-threads`.  The `queue-length` for this executor is always `0`, and by\ndefault has an unbounded number of threads.", :type :var, :members ()} {:name wait-pool, :file "manifold/executor.clj", :line 202, :arglists ([]), :type :var, :members ()} {:name with-executor, :file "manifold/executor.clj", :line 27, :arglists ([executor & body]), :type :macro, :members ()})} {:author "Zach Tellman", :doc "Methods for creating, transforming, and interacting with asynchronous values.\n", :name manifold.deferred, :publics ({:name ->deferred, :file "manifold/deferred.clj", :line 121, :arglists ([x] [x default-val]), :doc "Transforms `x` into a deferred if possible, or returns `default-val`.  If no default value\nis given, an `IllegalArgumentException` is thrown.", :type :var, :members ()} {:name add-listener!, :file "manifold/deferred.clj", :line 259, :arglists ([deferred listener]), :doc "Registers a listener which can be cancelled via `cancel-listener!`.  Unless this is useful, prefer `on-realized`.\n", :type :var, :members ()} {:name alt, :file "manifold/deferred.clj", :line 1125, :arglists ([& vals]), :doc "Takes a list of values, some of which may be deferrable, and returns a\ndeferred that will yield the value which was realized first.\n\n  @(alt 1 2) => 1\n  @(alt (future (Thread/sleep 1) 1)\n        (future (Thread/sleep 1) 2)) => 1 or 2 depending on the thread scheduling\n\nValues appearing earlier in the input are preferred.", :type :var, :members ()} {:name alt', :file "manifold/deferred.clj", :line 1104, :arglists ([& vals]), :doc "Like `alt`, but only unwraps Manifold deferreds.\n", :type :var, :members ()} {:name cancel-listener!, :file "manifold/deferred.clj", :line 264, :arglists ([deferred listener]), :doc "Cancels a listener which has been registered via `add-listener!`.\n", :type :var, :members ()} {:name catch, :file "manifold/deferred.clj", :line 969, :arglists ([x error-handler] [x error-class error-handler]), :doc "An equivalent of the catch clause, which takes an `error-handler` function that will be invoked\nwith the exception, and whose return value will be yielded as a successful outcome.  If an\n`error-class` is specified, only exceptions of that type will be caught.  If not, all exceptions\nwill be caught.\n\n    (-> d\n      (chain f g h)\n      (catch IOException #(str \"oh no, IO: \" (.getMessage %)))\n      (catch             #(str \"something unexpected: \" (.getMessage %))))\n\n ", :type :var, :members ()} {:name catch', :file "manifold/deferred.clj", :line 934, :arglists ([x error-handler] [x error-class error-handler]), :doc "Like `catch`, but does not coerce deferrable values.\n", :type :var, :members ()} {:name chain, :file "manifold/deferred.clj", :line 908, :arglists ([x] [x f] [x f g] [x f g & fs]), :doc "Composes functions, left to right, over the value `x`, returning a deferred containing\nthe result.  When composing, either `x` or the returned values may be values which can\nbe converted to a deferred, causing the composition to be paused.\n\nThe returned deferred will only be realized once all functions have been applied and their\nreturn values realized.\n\n    @(chain 1 inc #(future (inc %))) => 3\n\n    @(chain (future 1) inc inc) => 3\n\n", :type :var, :members ()} {:name chain', :file "manifold/deferred.clj", :line 892, :arglists ([x] [x f] [x f g] [x f g & fs]), :doc "Like `chain`, but does not coerce deferrable values.  This is useful both when coercion\nis undesired, or for 2-4x better performance than `chain`.", :type :var, :members ()} {:name claim!, :file "manifold/deferred.clj", :line 254, :arglists ([deferred]), :doc "Attempts to claim the deferred for future updates.  If successful, a claim token is returned, otherwise returns `nil`.\n", :type :var, :members ()} {:name connect, :file "manifold/deferred.clj", :line 620, :arglists ([a b]), :doc "Conveys the realized value of `a` into `b`.\n", :type :var, :members ()} {:name Deferrable, :file "manifold/deferred.clj", :line 42, :doc nil, :type :protocol, :members ()} {:name deferrable?, :file "manifold/deferred.clj", :line 95, :arglists ([x]), :doc "Returns true if the object can be coerced to a Manifold deferred.\n", :type :var, :members ()} {:name deferred, :file "manifold/deferred.clj", :line 558, :arglists ([] [executor]), :doc "Equivalent to Clojure's `promise`, but also allows asynchronous callbacks to be registered\nand composed via `chain`.", :type :var, :members ()} {:name deferred?, :file "manifold/deferred.clj", :line 87, :arglists ([x]), :doc "Returns true if the object is an instance of a Manifold deferred.\n", :type :var, :members ()} {:name error!, :file "manifold/deferred.clj", :line 247, :arglists ([deferred x] [deferred x claim-token]), :doc "Puts the deferred into an error state.\n", :type :var, :members ()} {:name error-deferred, :file "manifold/deferred.clj", :line 594, :arglists ([error] [error executor]), :doc "A deferred which already contains a realized error\n", :type :var, :members ()} {:name finally, :file "manifold/deferred.clj", :line 1022, :arglists ([x f]), :doc "An equivalent of the finally clause, which takes a no-arg side-effecting function that executes\nno matter what the result.", :type :var, :members ()} {:name finally', :file "manifold/deferred.clj", :line 991, :arglists ([x f]), :doc "Like `finally`, but doesn't coerce deferrable values.\n", :type :var, :members ()} {:name future, :file "manifold/deferred.clj", :line 660, :arglists ([& body]), :doc "Equivalent to Clojure's `future`, but returns a Manifold deferred.\n", :type :macro, :members ()} {:name future-with, :file "manifold/deferred.clj", :line 647, :arglists ([executor & body]), :doc "Equivalent to Clojure's `future`, but allows specification of the executor\nand returns a Manifold deferred.", :type :macro, :members ()} {:name let-flow, :file "manifold/deferred.clj", :line 1339, :arglists ([bindings & body]), :doc "A version of `let` where deferred values that are let-bound or closed over can be treated\nas if they are realized values.  The body will only be executed once all of the let-bound\nvalues, even ones only used for side effects, have been computed.\n\nReturns a deferred value, representing the value returned by the body.\n\n   (let-flow [x (future 1)]\n     (+ x 1))\n\n   (let-flow [x (future 1)\n              y (future (+ x 1))]\n     (+ y 1))\n\n   (let [x (future 1)]\n     (let-flow [y (future (+ x 1))]\n       (+ y 1)))", :type :macro, :members ()} {:name let-flow', :file "manifold/deferred.clj", :line 1363, :arglists ([bindings & body]), :doc "Like `let-flow`, but only for Manifold deferreds.\n", :type :macro, :members ()} {:name listener, :file "manifold/deferred.clj", :line 224, :arglists ([on-success] [on-success on-error]), :doc "Creates a listener which can be registered or cancelled via `add-listener!` and `cancel-listener!`.\n", :type :var, :members ()} {:name loop, :file "manifold/deferred.clj", :line 1183, :arglists ([bindings & body]), :doc "A version of Clojure's loop which allows for asynchronous loops, via `manifold.deferred/recur`.\n`loop` will always return a deferred value, even if the body is synchronous.  Note that `loop` does **not** coerce values to deferreds, actual Manifold deferreds must be used.\n\n (loop [i 1e6]\n   (chain (future i)\n     #(if (zero? %)\n        %\n        (recur (dec %)))))", :type :macro, :members ()} {:name on-realized, :file "manifold/deferred.clj", :line 80, :arglists ([x on-success on-error]), :doc "Registers callbacks with the manifold deferred for both success and error outcomes.\n", :type :var, :members ()} {:name onto, :file "manifold/deferred.clj", :line 638, :arglists ([d executor]), :doc "Returns a deferred whose callbacks will be run on `executor`.\n", :type :var, :members ()} {:name realized?, :file "manifold/deferred.clj", :line 53, :arglists ([x]), :doc "Returns true if the manifold deferred is realized.\n", :type :var, :members ()} {:name recur, :file "manifold/deferred.clj", :line 1178, :arglists ([& args]), :doc "A special recur that can be used with `manifold.deferred/loop`.\n", :type :var, :members ()} {:name success!, :file "manifold/deferred.clj", :line 240, :arglists ([deferred x] [deferred x claim-token]), :doc "Equivalent to `deliver`, but allows a `claim-token` to be passed in.\n", :type :var, :members ()} {:name success-deferred, :file "manifold/deferred.clj", :line 573, :arglists ([val] [val executor]), :doc "A deferred which already contains a realized value\n", :type :var, :members ()} {:name timeout!, :file "manifold/deferred.clj", :line 1139, :arglists ([d interval] [d interval timeout-value]), :doc "Takes a deferred, and sets a timeout on it, such that it will be realized as `timeout-value`\n(or a TimeoutException if none is specified) if it is not realized in `interval` ms.  Returns\nthe deferred that was passed in.\n\nThis will act directly on the deferred value passed in.  If the deferred represents a value\nreturned by `chain`, all actions not yet completed will be short-circuited upon timeout.", :type :var, :members ()} {:name unwrap, :file "manifold/deferred.clj", :line 611, :arglists ([x]), :type :var, :members ()} {:name unwrap', :file "manifold/deferred.clj", :line 603, :arglists ([x]), :type :var, :members ()} {:name zip, :file "manifold/deferred.clj", :line 1078, :arglists ([& vals]), :doc "Takes a list of values, some of which may be deferrable, and returns a deferred that will yield a list\nof realized values.\n\n     @(zip 1 2 3) => [1 2 3]\n     @(zip (future 1) 2 3) => [1 2 3]\n\n", :type :var, :members ()} {:name zip', :file "manifold/deferred.clj", :line 1030, :arglists ([& vals]), :doc "Like `zip`, but only unwraps Manifold deferreds.\n", :type :var, :members ()})} {:author "Zach Tellman", :doc "An implementation of an event bus, where publishers and subscribers can interact via topics.\n", :name manifold.bus, :publics ({:name active?, :file "manifold/bus.clj", :line 43, :arglists ([bus topic]), :doc "Returns `true` if there are any subscribers to `topic`.\n", :type :var, :members ()} {:name downstream, :file "manifold/bus.clj", :line 38, :arglists ([bus topic]), :doc "Returns a list of all streams subscribed to `topic`.\n", :type :var, :members ()} {:name event-bus, :file "manifold/bus.clj", :line 89, :arglists ([] [stream-generator]), :doc "Returns an event bus that can be used with `publish!` and `subscribe`.\n", :type :var, :members ()} {:name publish!, :file "manifold/bus.clj", :line 25, :arglists ([bus topic message]), :doc "Publishes a message on the bus, returning a deferred result representing the message\nbeing accepted by all subscribers.  To prevent one slow consumer from blocking all\nthe others, use `manifold.stream/buffer`, or `manifold.stream/connect` with a timeout\nspecified.", :type :var, :members ()} {:name subscribe, :file "manifold/bus.clj", :line 33, :arglists ([bus topic]), :doc "Returns a stream which consumes all messages from `topic`.\n", :type :var, :members ()} {:name topic->subscribers, :file "manifold/bus.clj", :line 48, :arglists ([bus]), :type :var, :members ()})} {:author "Zach Tellman", :doc "This namespace contains methods for converting units of time, with milliseconds as the base representation, and for deferring execution of functions to some time in the future.  In practice, the methods here are not necessary to use Manifold effectively - `manifold.deferred/timeout` and `manifold.stream/periodically` are more directly useful - but they are available for anyone who should need them.\n", :name manifold.time, :publics ({:name *clock*, :file "manifold/time.clj", :line 236, :dynamic true, :type :var, :members ()} {:name add, :file "manifold/time.clj", :line 116, :arglists ([timestamp value unit]), :doc "Takes a `timestamp`, and adds `value` multiples of `unit` to the value.\n", :type :var, :members ()} {:name at, :file "manifold/time.clj", :line 273, :arglists ([timestamp f]), :doc "Schedules no-arg function  `f` to be invoked at `timestamp`, which is the milliseconds\nsince the epoch.  Returns a deferred representing the returned value of the function.", :type :var, :members ()} {:name days, :file "manifold/time.clj", :line 53, :arglists ([n]), :doc "Converts days -> milliseconds\n", :type :var, :members ()} {:name every, :file "manifold/time.clj", :line 261, :arglists ([period f] [period initial-delay f]), :doc "Schedules no-arg function `f` to be invoked every `period` milliseconds, after `initial-delay`\nmilliseconds, which defaults to `0`.  Returns a zero-argument function which, when invoked,\ncancels the repeated invocation.\n\nIf the invocation of `f` ever throws an exception, repeated invocation is automatically\ncancelled.", :type :var, :members ()} {:name floor, :file "manifold/time.clj", :line 101, :arglists ([timestamp unit]), :doc "Takes a `timestamp`, and rounds it down to the nearest even multiple of the `unit`.\n\n(floor 1001 :second) => 1000\n(floor (seconds 61) :minute) => 60000\n\n", :type :var, :members ()} {:name format-duration, :file "manifold/time.clj", :line 69, :arglists ([n]), :doc "Takes a duration in milliseconds, and returns a formatted string\ndescribing the interval, i.e. '5d 3h 1m'", :type :var, :members ()} {:name hours, :file "manifold/time.clj", :line 48, :arglists ([n]), :doc "Converts hours -> milliseconds\n", :type :var, :members ()} {:name hz, :file "manifold/time.clj", :line 58, :arglists ([n]), :doc "Converts frequency -> period in milliseconds\n", :type :var, :members ()} {:name IMockClock, :file "manifold/time.clj", :line 137, :doc nil, :type :protocol, :members ({:name advance, :arglists ([clock time]), :doc "Advances the mock clock by the specified interval of `time`.\n\nAdvancing the clock is a continuous action - the clock doesn't just jump\nfrom `now` to `new-now = (+ (now clock) time)`. Rather, for each scheduled\nevent within `[now; new-now]` the clock is reset to the time of the event\nand the event function is executed.\n\nFor example, if you have a periodic function scheduled with\n\n  (every 1 #(swap! counter inc))\n\nand advance the clock by 5, the counter will be incremented 6 times in\ntotal: once initially, as the initial delay is 0 and 5 times for every 1 ms\nstep of the clock.", :type :var, :members ()} {:name now, :arglists ([clock]), :doc "Returns the current time for the clock\n", :type :var, :members ()})} {:name in, :file "manifold/time.clj", :line 248, :arglists ([interval f]), :doc "Schedules no-arg function `f` to be invoked in `interval` milliseconds.  Returns a deferred\nrepresenting the returned value of the function.", :type :var, :members ()} {:name microseconds, :file "manifold/time.clj", :line 28, :arglists ([n]), :doc "Converts microseconds -> milliseconds\n", :type :var, :members ()} {:name milliseconds, :file "manifold/time.clj", :line 33, :arglists ([n]), :doc "Converts milliseconds -> milliseconds\n", :type :var, :members ()} {:name minutes, :file "manifold/time.clj", :line 43, :arglists ([n]), :doc "Converts minutes -> milliseconds\n", :type :var, :members ()} {:name mock-clock, :file "manifold/time.clj", :line 179, :arglists ([] [initial-time]), :doc "Creates a clock designed for testing scheduled behaviors.  It can replace the default\nscheduler using `with-clock`, and can be advanced to a particular time via `advance`.  By\ndefault, the initial time is `0`.", :type :var, :members ()} {:name nanoseconds, :file "manifold/time.clj", :line 23, :arglists ([n]), :doc "Converts nanoseconds -> milliseconds\n", :type :var, :members ()} {:name scheduled-executor->clock, :file "manifold/time.clj", :line 162, :arglists ([e]), :type :var, :members ()} {:name seconds, :file "manifold/time.clj", :line 38, :arglists ([n]), :doc "Converts seconds -> milliseconds\n", :type :var, :members ()} {:name with-clock, :file "manifold/time.clj", :line 241, :arglists ([clock & body]), :doc "Ensures that all calls to `every` and `in` are made through the specified clock, rather\nthan the default one.", :type :macro, :members ()})}]}, :pom-str "<?xml version=\"1.0\" encoding=\"UTF-8\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>manifold</groupId>\n  <artifactId>manifold</artifactId>\n  <packaging>jar</packaging>\n  <version>0.1.8</version>\n  <name>manifold</name>\n  <description>a compatibility layer for event-driven abstractions</description>\n  <url>https://github.com/ztellman/manifold</url>\n  <licenses>\n    <license>\n      <name>MIT License</name>\n      <url>http://opensource.org/licenses/MIT</url>\n    </license>\n  </licenses>\n  <scm>\n    <url>https://github.com/ztellman/eventual</url>\n    <connection>scm:git:git://github.com/ztellman/eventual.git</connection>\n    <developerConnection>scm:git:ssh://git@github.com/ztellman/eventual.git</developerConnection>\n    <tag>72a5bd368bbb6a1fe1a3cfe51a95a0139ef7b828</tag>\n  </scm>\n  <build>\n    <sourceDirectory>src</sourceDirectory>\n    <testSourceDirectory>test</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>resources</directory>\n      </testResource>\n    </testResources>\n    <directory>target</directory>\n    <outputDirectory>target/classes</outputDirectory>\n    <plugins/>\n  </build>\n  <repositories>\n    <repository>\n      <id>central</id>\n      <url>https://repo1.maven.org/maven2/</url>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n    <repository>\n      <id>clojars</id>\n      <url>https://repo.clojars.org/</url>\n      <snapshots>\n        <enabled>true</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n  </repositories>\n  <dependencyManagement>\n    <dependencies/>\n  </dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>tools.logging</artifactId>\n      <version>0.3.1</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>clojure</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n    </dependency>\n    <dependency>\n      <groupId>io.aleph</groupId>\n      <artifactId>dirigiste</artifactId>\n      <version>0.1.5</version>\n    </dependency>\n    <dependency>\n      <groupId>riddley</groupId>\n      <artifactId>riddley</artifactId>\n      <version>0.1.14</version>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojure</artifactId>\n      <version>1.8.0</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>criterium</groupId>\n      <artifactId>criterium</artifactId>\n      <version>0.4.4</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>core.async</artifactId>\n      <version>0.2.385</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n<!-- This file was autogenerated by Leiningen.\n  Please do not edit it directly; instead edit project.clj and regenerate it.\n  It should not be considered canonical data. For more information see\n  https://github.com/technomancy/leiningen -->\n"}