{:group-id "semantic-csv", :artifact-id "semantic-csv", :version "0.2.1-alpha1", :codox {"clj" [{:doc "# Transducers API namespace\n", :name semantic-csv.transducers, :publics ({:name ->boolean, :file "semantic_csv/transducers.cljc", :line 308, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to boolean from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->double, :file "semantic_csv/transducers.cljc", :line 309, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to double from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->float, :file "semantic_csv/transducers.cljc", :line 310, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to float from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->idiomatic-keyword, :file "semantic_csv/transducers.cljc", :line 307, :arglists ([x]), :doc "Takes a string, replacing consecutive underscores and spaces with a single dash(-),\nthen returns a keyword based on the transformed string.", :type :var, :members ()} {:name ->int, :file "semantic_csv/transducers.cljc", :line 312, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to int from string or other numeric. If string represents a non integer value,\nit will be rounded down to the nearest int.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->long, :file "semantic_csv/transducers.cljc", :line 311, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to long from string or other numeric. If string represents a non integer value,\nwill be rounded down to the nearest long.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name batch, :file "semantic_csv/transducers.cljc", :line 420, :arglists ([n]), :doc "Returns a transducer that will return a sequence of row batches, where the batch\nsize is n.", :type :var, :members ()} {:name cast-with, :file "semantic_csv/transducers.cljc", :line 145, :arglists ([cast-fns] [cast-fns {:as opts, :keys [except-first exception-handler only]}]), :doc "Returns a transducer that casts the vals of each row according to `cast-fns`, which must either\nbe a map of `column-name -> casting-fn` or a single casting function to be applied towards all columns.\nOptions include:\n\n* `:except-first` - Leaves the first row unaltered; useful for preserving header row.\n* `:exception-handler` - If cast-fn raises an exception, this function will be called with args\n  `colname, value`, and the result used as the parse value.\n* `:only` - Only cast the specified column(s); can be either a single column name, or a vector of them.", :type :var, :members ()} {:name mappify, :file "semantic_csv/transducers.cljc", :line 21, :arglists ([] [{:as opts, :keys [keyify transform-header header], :or {keyify true}}]), :doc "Returns a transducer that transforms row vectors into maps, where keys are taken as the first row or as\nspecified via `:header` option.  Options include:\n\n* `:keyify` - bool; specify whether header/column names should be turned into keywords (default: `true`).\n* `:header` - specify the header to use for map keys, preventing first row of data from being consumed as header.\n* `:transform-header` - specify a transformation function for each header key (ignored if `:header` or `:keyify` is specified).", :type :var, :members ()} {:name parse-and-process, :file "semantic_csv/transducers.cljc", :line 257, :arglists ([csv-readable & {:keys [parser-opts], :or {parser-opts {}}, :as opts}]), :doc "This is a convenience function for reading a csv file using `clojure-csv` and passing it through `process`\nwith the given set of options (specified _last_ as kw args, in contrast with our other processing functions).\nNote that `:parser-opts` can be specified and will be passed along to `clojure-csv/parse-csv`", :type :var, :members ()} {:name process, :file "semantic_csv/transducers.cljc", :line 209, :arglists ([] [{:keys [mappify keyify header transform-header remove-comments comment-re comment-char structs cast-fns cast-exception-handler cast-only], :or {mappify true, keyify true, remove-comments true, comment-re #regex "^\\#"}, :as opts}]), :doc "Returns a transducers that composes the most frequently used input processing capabilities,\nand is controlled by an `opts` hash with opinionated defaults:\n\n* `:mappify` - bool; transform rows from vectors into maps using `mappify`.\n* `:keyify` - bool; specify whether header/column names should be turned into keywords (default: `true`).\n* `:transform-header` - specify a transformation function for each header key (ignored if `:header` or `:keyify` is specified).\n* `:header` - specify header to be used in mappify; as per `mappify`, first row will not be consumed as header\n* `:structs` - bool; use structify insead of mappify\n* `:remove-comments` - bool; remove comment lines, as specified by `:comment-re` or `:comment-char`. Also\n   removes empty lines. Defaults to `true`.\n* `:comment-re` - specify a regular expression to use for commenting out lines.\n* `:comment-char` - specify a comment character to use for filtering out comments; overrides comment-re.\n* `:cast-fns` - optional map of `colname | index -> cast-fn`; row maps will have the values as output by the\n   assigned `cast-fn`.\n* `:cast-exception-handler` - If cast-fn raises an exception, this function will be called with args\n  `colname, value`, and the result used as the parse value.\n* `:cast-only` - Only cast the specified column(s); can be either a single column name, or a vector of them.", :type :var, :members ()} {:name remove-comments, :file "semantic_csv/transducers.cljc", :line 107, :arglists ([] [{:as opts, :keys [comment-re comment-char]}]), :doc "Returns a transducer that removes rows starting with a comment character (by default, `#`).\nOperates by checking whether the first item of every row in the collection matches a comment pattern.\nAlso removes empty lines. Options include:\n\n* `:comment-re` - Specify a custom regular expression for determining which lines are commented out.\n* `:comment-char` - Checks for lines lines starting with this char.\n\nNote: this function only works (or makes sense) with rows that are vectors, and so should always be used\nbefore mappify.", :type :var, :members ()} {:name slurp-csv, :file "semantic_csv/transducers.cljc", :line 282, :arglists ([csv-filename & {:as opts}]), :doc "This convenience function let's you `parse-and-process` csv data given a csv filename. Note that it is _not_\nlazy, and must read in all data so the file handle can be closed.", :type :var, :members ()} {:name spit-csv, :file "semantic_csv/transducers.cljc", :line 444, :arglists ([file rows] [file {:keys [batch-size cast-fns writer-opts header prepend-header], :or {batch-size 20, prepend-header true}, :as opts} rows]), :doc "Convenience function for spitting out CSV data to a file using `clojure-csv`.\n\n* `file` - Can be either a filename string, or a file handle.\n* `opts` - Optional hash of settings.\n* `rows` - Can be a sequence of either maps or vectors; if the former, vectorize will be\n    called on the input with `:header` argument specifiable through `opts`.\n\nThe Options hash can have the following mappings:\n\n* `:batch-size` - How many rows to format and write at a time?\n* `:cast-fns` - Formatter(s) to be run on row values. As with `cast-with` function, can be either a map\n   of `column-name -> cast-fn`, or a single function to be applied to all values. Note that `str` is called\n   on all values just before writing regardless of `:cast-fns`.\n* `:writer-opts` - Options hash to be passed along to `clojure-csv.core/write-csv`.\n* `:header` - Header to be passed along to `vectorize`, if necessary.\n* `:prepend-header` - Should the header be prepended to the rows written if `vectorize` is called?", :type :var, :members ()} {:name structify, :file "semantic_csv/transducers.cljc", :line 65, :arglists ([] [{:as opts, :keys [keyify transform-header header], :or {keyify true}}]), :doc "Takes an optional map of input options and returns a transducer.  The transducer transforms row vectors into structs,\nwhere keys are taken as the first row or as specified via `:header` option.  This is analogous to mappify.  Options:\n\n* `:keyify` - bool; specify whether header/column names should be turned into keywords (default: `true`).\n* `:header` - specify the header to use for map keys, preventing first row of data from being consumed as header.\n* `:transform-header` - specify a transformation function for each header key (ignored if `:header` or `:keyify` is specified).", :type :var, :members ()} {:name vectorize, :file "semantic_csv/transducers.cljc", :line 361, :arglists ([] [{:keys [header prepend-header format-header], :or {prepend-header true, format-header impl/stringify-keyword}}]), :doc "Returns a transducer that transforms maps into vectors. Options include:\n\n* `:header` - The header to be used. If not specified, this defaults to `(-> rows first keys)`. Only\n  values corresponding to the specified header will be included in the output, and will be included in the\n  order corresponding to this argument.\n* `:prepend-header` - Defaults to true, and controls whether the `:header` vector should be prepended\n  to the output sequence.\n* `:format-header` - If specified, this function will be called on each element of the `:header` vector, and\n  the result prepended to the output sequence. The default behaviour is to leave strings alone but stringify\n  keyword names such that the `:` is removed from their string representation. Passing a falsey value will\n  leave the header unaltered in the output.", :type :var, :members ()})} {:doc "This namespace consists of implementation details for the main API\n", :name semantic-csv.impl.core, :publics ({:name ?>>, :file "semantic_csv/impl/core.cljc", :line 123, :arglists ([do-it? & args]), :doc "Conditional double-arrow operation (->> nums (?>> inc-all? (map inc)))\n", :type :macro, :members ()} {:name apply-kwargs, :file "semantic_csv/impl/core.cljc", :line 13, :arglists ([f & args]), :doc "Utility that takes a function f, any number of regular args, and a final kw-args argument which will be\nsplatted in as a final argument", :type :var, :members ()} {:name cast-row, :file "semantic_csv/impl/core.cljc", :line 46, :arglists ([cast-fns row & {:keys [only exception-handler]}]), :doc "Format the values of row with the given function. This gives us some flexbility with respect to formatting\nboth vectors and maps in similar fashion.", :type :var, :members ()} {:name clone-var, :file "semantic_csv/impl/core.cljc", :line 79, :arglists ([fsym]), :doc "Clone the var pointed to by fsym into current ns such that arglists, name and doc metadata are preserned.\n", :type :macro, :members ()} {:name mappify-row, :file "semantic_csv/impl/core.cljc", :line 7, :arglists ([header row]), :doc "Translates a single row of values into a map of `colname -> val`, given colnames in `header`.\n", :type :var, :members ()} {:name not-blank?, :file "semantic_csv/impl/core.cljc", :line 68, :doc "Check if value is a non-blank string.\n", :type :var, :members ()} {:name row-val-caster, :file "semantic_csv/impl/core.cljc", :line 34, :arglists ([cast-fns exception-handler]), :doc "Returns a function that casts casts a single row value based on specified casting function and\noptionally excpetion handler", :type :var, :members ()} {:name stringify-keyword, :file "semantic_csv/impl/core.cljc", :line 24, :arglists ([x]), :doc "Leaves strings alone. Turns keywords into the stringified version of the keyword, sans the initial `:`\ncharacter. On anything else, calls str.", :type :var, :members ()})} {:doc "# Core API namespace\n", :name semantic-csv.core, :publics ({:name ->boolean, :file "semantic_csv/core.cljc", :line 324, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to boolean from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->double, :file "semantic_csv/core.cljc", :line 325, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to double from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->float, :file "semantic_csv/core.cljc", :line 326, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to float from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->idiomatic-keyword, :file "semantic_csv/core.cljc", :line 323, :arglists ([x]), :doc "Takes a string, replacing consecutive underscores and spaces with a single dash(-),\nthen returns a keyword based on the transformed string.", :type :var, :members ()} {:name ->int, :file "semantic_csv/core.cljc", :line 328, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to int from string or other numeric. If string represents a non integer value,\nit will be rounded down to the nearest int.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->long, :file "semantic_csv/core.cljc", :line 327, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to long from string or other numeric. If string represents a non integer value,\nwill be rounded down to the nearest long.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name batch, :file "semantic_csv/core.cljc", :line 422, :arglists ([n rows]), :doc "Takes sequence of items and returns a sequence of batches of items from the original\nsequence, at most `n` long.", :type :var, :members ()} {:name cast-with, :file "semantic_csv/core.cljc", :line 148, :arglists ([cast-fns rows] [cast-fns opts rows]), :doc "Casts the vals of each row according to `cast-fns`, which must either be a map of\n`column-name -> casting-fn` or a single casting function to be applied towards all columns.\nAdditionally, an `opts` map can be used to specify:\n\n* `:except-first` - Leaves the first row unaltered; useful for preserving header row.\n* `:exception-handler` - If cast-fn raises an exception, this function will be called with args\n  `colname, value`, and the result used as the parse value.\n* `:only` - Only cast the specified column(s); can be either a single column name, or a vector of them.", :type :var, :members ()} {:name except-first, :file "semantic_csv/core.cljc", :line 206, :arglists ([& forms-and-data]), :doc "Takes any number of forms and a final `data` argument. Threads the data through the forms, as though\nwith `->>`, except that the first item in `data` remains unaltered. This is intended to operate within\nthe context of an _actual_ `->>` threading macro for processing, where you might want to leave a header\ncolumn unmodified by your processing functions.", :type :macro, :members ()} {:name mappify, :file "semantic_csv/core.cljc", :line 69, :arglists ([rows] [{:keys [keyify transform-header header structs], :or {keyify true}, :as opts} rows]), :doc "Takes a sequence of row vectors, as commonly produced by csv parsing libraries, and returns a sequence of\nmaps. By default, the first row vector will be interpreted as a header, and used as the keys for the maps.\nHowever, this and other behaviour are customizable via an optional `opts` map with the following options:\n\n* `:keyify` - bool; specify whether header/column names should be turned into keywords (default: `true`).\n  If `:transform-header` is present, this option will be ignored.\n* `:transform-header` - A function that transforms the header/column names for each column.\n  This takes precedence over `keyify` and should be a function that takes a string.\n* `:header` - specify the header to use for map keys, preventing first row of data from being consumed as header.\n* `:structs` - bool; use structs instead of hash-maps or array-maps, for performance boost (default: `false`).", :type :var, :members ()} {:name parse-and-process, :file "semantic_csv/core.cljc", :line 277, :arglists ([csv-readable & {:keys [parser-opts], :or {parser-opts {}}, :as opts}]), :doc "This is a convenience function for reading a csv file using `clojure/data.csv` and passing it through `process`\nwith the given set of options (specified _last_ as kw_args, in contrast with our other processing functions).\nNote that `:parser-opts` can be specified and will be passed along to `clojure-csv/parse-csv`", :type :var, :members ()} {:name process, :file "semantic_csv/core.cljc", :line 242, :arglists ([opts rows] [rows]), :doc "This function wraps together the most frequently used input processing capabilities,\ncontrolled by an `opts` hash with opinionated defaults:\n\n* `:mappify` - bool; transform rows from vectors into maps using `mappify`.\n* `:keyify` - bool; specify whether header/column names should be turned into keywords (default: `true`).\n* `:header` - specify header to be used in mappify; as per `mappify`, first row will not be consumed as header\n* `:structs` - bool; use structs instead of array-maps or hash-maps in mappify.\n* `:remove-comments` - bool; remove comment lines, as specified by `:comment-re` or `:comment-char`. Also\n   removes empty lines. Defaults to `true`.\n* `:comment-re` - specify a regular expression to use for commenting out lines.\n* `:comment-char` - specify a comment character to use for filtering out comments; overrides comment-re.\n* `:cast-fns` - optional map of `colname | index -> cast-fn`; row maps will have the values as output by the\n   assigned `cast-fn`.\n* `:cast-exception-handler` - If cast-fn raises an exception, this function will be called with args\n  `colname, value`, and the result used as the parse value.\n* `:cast-only` - Only cast the specified column(s); can be either a single column name, or a vector of them.", :type :var, :members ()} {:name remove-comments, :file "semantic_csv/core.cljc", :line 111, :arglists ([rows] [opts rows]), :doc "Removes rows which start with a comment character (by default, `#`). Operates by checking whether\nthe first item of every row in the collection matches a comment pattern. Also removes empty lines.\nOptions include:\n\n* `:comment-re` - Specify a custom regular expression for determining which lines are commented out.\n* `:comment-char` - Checks for lines lines starting with this char.\n\nNote: this function only works with rows that are vectors, and so should always be used before mappify.", :type :var, :members ()} {:name slurp-csv, :file "semantic_csv/core.cljc", :line 298, :arglists ([csv-filename & {:as opts}]), :doc "This convenience function let's you `parse-and-process` csv data given a csv filename. Note that it is _not_\nlazy, and must read in all data so the file handle can be closed.", :type :var, :members ()} {:name spit-csv, :file "semantic_csv/core.cljc", :line 445, :arglists ([file rows] [file opts rows]), :doc "Convenience function for spitting out CSV data to a file using `clojure-csv`.\n\n* `file` - Can be either a filename string, or a file handle.\n* `opts` - Optional hash of settings.\n* `rows` - Can be a sequence of either maps or vectors; if the former, vectorize will be\n    called on the input with `:header` argument specifiable through `opts`.\n\nThe Options hash can have the following mappings:\n\n* `:batch-size` - How many rows to format and write at a time?\n* `:cast-fns` - Formatter(s) to be run on row values. As with `cast-with` function, can be either a map\n   of `column-name -> cast-fn`, or a single function to be applied to all values. Note that `str` is called\n   on all values just before writing regardless of `:cast-fns`.\n* `:writer-opts` - Options hash to be passed along to `clojure-csv.core/write-csv`.\n* `:header` - Header to be passed along to `vectorize`, if necessary.\n* `:prepend-header` - Should the header be prepended to the rows written if `vectorize` is called?", :type :var, :members ()} {:name vectorize, :file "semantic_csv/core.cljc", :line 375, :arglists ([rows] [opts rows]), :doc "Take a sequence of maps, and transform them into a sequence of vectors. Options:\n\n* `:header` - The header to be used. If not specified, this defaults to `(-> rows first keys)`. Only\n  values corresponding to the specified header will be included in the output, and will be included in the\n  order corresponding to this argument.\n* `:prepend-header` - Defaults to true, and controls whether the `:header` vector should be prepended\n  to the output sequence.\n* `:format-header` - If specified, this function will be called on each element of the `:header` vector, and\n  the result prepended to the output sequence. The default behaviour is to leave strings alone but stringify\n  keyword names such that the `:` is removed from their string representation. Passing a falsey value will\n  leave the header unaltered in the output.", :type :var, :members ()})} {:name semantic-csv.casters, :publics ({:name ->boolean, :file "semantic_csv/casters.cljc", :line 104, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to boolean from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->double, :file "semantic_csv/casters.cljc", :line 88, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to double from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->float, :file "semantic_csv/casters.cljc", :line 71, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to float from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->idiomatic-keyword, :file "semantic_csv/casters.cljc", :line 11, :arglists ([x]), :doc "Takes a string, replacing consecutive underscores and spaces with a single dash(-),\nthen returns a keyword based on the transformed string.", :type :var, :members ()} {:name ->int, :file "semantic_csv/casters.cljc", :line 31, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to int from string or other numeric. If string represents a non integer value,\nit will be rounded down to the nearest int.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()} {:name ->long, :file "semantic_csv/casters.cljc", :line 51, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to long from string or other numeric. If string represents a non integer value,\nwill be rounded down to the nearest long.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :type :var, :members ()})}], "cljs" [{:name semantic-csv.casters, :doc nil, :publics ({:name ->boolean, :line 104, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to boolean from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :file "semantic_csv/casters.cljc", :type :var, :members ()} {:name ->double, :line 88, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to double from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :file "semantic_csv/casters.cljc", :type :var, :members ()} {:name ->float, :line 71, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to float from string or other numeric.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :file "semantic_csv/casters.cljc", :type :var, :members ()} {:name ->idiomatic-keyword, :line 11, :arglists ([x]), :doc "Takes a string, replacing consecutive underscores and spaces with a single dash(-),\nthen returns a keyword based on the transformed string.", :file "semantic_csv/casters.cljc", :type :var, :members ()} {:name ->int, :line 31, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to int from string or other numeric. If string represents a non integer value,\nit will be rounded down to the nearest int.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :file "semantic_csv/casters.cljc", :type :var, :members ()} {:name ->long, :line 51, :arglists ([x] [{:keys [nil-fill]} x]), :doc "Translate to long from string or other numeric. If string represents a non integer value,\nwill be rounded down to the nearest long.\n\nAn opts map can be specified as the first arguments with the following options:\n* `:nil-fill` - return this when input is empty/nil.", :file "semantic_csv/casters.cljc", :type :var, :members ()})} {:name semantic-csv.core, :doc "# Core API namespace\n", :publics ({:name ->boolean, :line 331, :file "semantic_csv/core.cljc", :type :var, :members ()} {:name ->double, :line 332, :file "semantic_csv/core.cljc", :type :var, :members ()} {:name ->float, :line 333, :file "semantic_csv/core.cljc", :type :var, :members ()} {:name ->idiomatic-keyword, :line 330, :file "semantic_csv/core.cljc", :type :var, :members ()} {:name ->int, :line 335, :file "semantic_csv/core.cljc", :type :var, :members ()} {:name ->long, :line 334, :file "semantic_csv/core.cljc", :type :var, :members ()} {:name batch, :line 422, :arglists ([n rows]), :doc "Takes sequence of items and returns a sequence of batches of items from the original\nsequence, at most `n` long.", :file "semantic_csv/core.cljc", :type :var, :members ()} {:name cast-with, :line 148, :arglists ([cast-fns rows] [cast-fns opts rows]), :doc "Casts the vals of each row according to `cast-fns`, which must either be a map of\n`column-name -> casting-fn` or a single casting function to be applied towards all columns.\nAdditionally, an `opts` map can be used to specify:\n\n* `:except-first` - Leaves the first row unaltered; useful for preserving header row.\n* `:exception-handler` - If cast-fn raises an exception, this function will be called with args\n  `colname, value`, and the result used as the parse value.\n* `:only` - Only cast the specified column(s); can be either a single column name, or a vector of them.", :file "semantic_csv/core.cljc", :type :var, :members ()} {:name except-first, :line 206, :arglists ([&form &env & forms-and-data]), :doc "Takes any number of forms and a final `data` argument. Threads the data through the forms, as though\nwith `->>`, except that the first item in `data` remains unaltered. This is intended to operate within\nthe context of an _actual_ `->>` threading macro for processing, where you might want to leave a header\ncolumn unmodified by your processing functions.", :file "/var/folders/8g/glv37m8n73gf4x0fqy5whqjc0000gn/T/cljdoc-semantic-csv-0.2.1-alpha17876913422816717777/contents/semantic_csv/core.cljc", :type :macro, :members ()} {:name mappify, :line 69, :arglists ([rows] [{:keys [keyify transform-header header structs], :or {keyify true}, :as opts} rows]), :doc "Takes a sequence of row vectors, as commonly produced by csv parsing libraries, and returns a sequence of\nmaps. By default, the first row vector will be interpreted as a header, and used as the keys for the maps.\nHowever, this and other behaviour are customizable via an optional `opts` map with the following options:\n\n* `:keyify` - bool; specify whether header/column names should be turned into keywords (default: `true`).\n  If `:transform-header` is present, this option will be ignored.\n* `:transform-header` - A function that transforms the header/column names for each column.\n  This takes precedence over `keyify` and should be a function that takes a string.\n* `:header` - specify the header to use for map keys, preventing first row of data from being consumed as header.\n* `:structs` - bool; use structs instead of hash-maps or array-maps, for performance boost (default: `false`).", :file "semantic_csv/core.cljc", :type :var, :members ()} {:name process, :line 242, :arglists ([opts rows] [rows]), :doc "This function wraps together the most frequently used input processing capabilities,\ncontrolled by an `opts` hash with opinionated defaults:\n\n* `:mappify` - bool; transform rows from vectors into maps using `mappify`.\n* `:keyify` - bool; specify whether header/column names should be turned into keywords (default: `true`).\n* `:header` - specify header to be used in mappify; as per `mappify`, first row will not be consumed as header\n* `:structs` - bool; use structs instead of array-maps or hash-maps in mappify.\n* `:remove-comments` - bool; remove comment lines, as specified by `:comment-re` or `:comment-char`. Also\n   removes empty lines. Defaults to `true`.\n* `:comment-re` - specify a regular expression to use for commenting out lines.\n* `:comment-char` - specify a comment character to use for filtering out comments; overrides comment-re.\n* `:cast-fns` - optional map of `colname | index -> cast-fn`; row maps will have the values as output by the\n   assigned `cast-fn`.\n* `:cast-exception-handler` - If cast-fn raises an exception, this function will be called with args\n  `colname, value`, and the result used as the parse value.\n* `:cast-only` - Only cast the specified column(s); can be either a single column name, or a vector of them.", :file "semantic_csv/core.cljc", :type :var, :members ()} {:name remove-comments, :line 111, :arglists ([rows] [opts rows]), :doc "Removes rows which start with a comment character (by default, `#`). Operates by checking whether\nthe first item of every row in the collection matches a comment pattern. Also removes empty lines.\nOptions include:\n\n* `:comment-re` - Specify a custom regular expression for determining which lines are commented out.\n* `:comment-char` - Checks for lines lines starting with this char.\n\nNote: this function only works with rows that are vectors, and so should always be used before mappify.", :file "semantic_csv/core.cljc", :type :var, :members ()} {:name vectorize, :line 375, :arglists ([rows] [opts rows]), :doc "Take a sequence of maps, and transform them into a sequence of vectors. Options:\n\n* `:header` - The header to be used. If not specified, this defaults to `(-> rows first keys)`. Only\n  values corresponding to the specified header will be included in the output, and will be included in the\n  order corresponding to this argument.\n* `:prepend-header` - Defaults to true, and controls whether the `:header` vector should be prepended\n  to the output sequence.\n* `:format-header` - If specified, this function will be called on each element of the `:header` vector, and\n  the result prepended to the output sequence. The default behaviour is to leave strings alone but stringify\n  keyword names such that the `:` is removed from their string representation. Passing a falsey value will\n  leave the header unaltered in the output.", :file "semantic_csv/core.cljc", :type :var, :members ()})} {:name semantic-csv.impl.core, :doc "This namespace consists of implementation details for the main API\n", :publics ({:name ?>>, :line 123, :arglists ([&form &env do-it? & args]), :doc "Conditional double-arrow operation (->> nums (?>> inc-all? (map inc)))\n", :file "/var/folders/8g/glv37m8n73gf4x0fqy5whqjc0000gn/T/cljdoc-semantic-csv-0.2.1-alpha17876913422816717777/contents/semantic_csv/impl/core.cljc", :type :macro, :members ()} {:name apply-kwargs, :line 13, :arglists ([f & args]), :doc "Utility that takes a function f, any number of regular args, and a final kw-args argument which will be\nsplatted in as a final argument", :file "semantic_csv/impl/core.cljc", :type :var, :members ()} {:name cast-row, :line 46, :arglists ([cast-fns row & {:keys [only exception-handler]}]), :doc "Format the values of row with the given function. This gives us some flexbility with respect to formatting\nboth vectors and maps in similar fashion.", :file "semantic_csv/impl/core.cljc", :type :var, :members ()} {:name clone-var, :line 79, :arglists ([fsym]), :doc "Clone the var pointed to by fsym into current ns such that arglists, name and doc metadata are preserned.\n", :file "semantic_csv/impl/core.cljc", :type :macro, :members ()} {:name mappify-row, :line 7, :arglists ([header row]), :doc "Translates a single row of values into a map of `colname -> val`, given colnames in `header`.\n", :file "semantic_csv/impl/core.cljc", :type :var, :members ()} {:name not-blank?, :line 68, :doc "Check if value is a non-blank string.\n", :file "semantic_csv/impl/core.cljc", :type :var, :members ()} {:name row-val-caster, :line 34, :arglists ([cast-fns exception-handler]), :doc "Returns a function that casts casts a single row value based on specified casting function and\noptionally excpetion handler", :file "semantic_csv/impl/core.cljc", :type :var, :members ()} {:name stringify-keyword, :line 24, :arglists ([x]), :doc "Leaves strings alone. Turns keywords into the stringified version of the keyword, sans the initial `:`\ncharacter. On anything else, calls str.", :file "semantic_csv/impl/core.cljc", :type :var, :members ()})} {:name semantic-csv.transducers, :doc "# Transducers API namespace\n", :publics ({:name ->boolean, :line 315, :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name ->double, :line 316, :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name ->float, :line 317, :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name ->idiomatic-keyword, :line 314, :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name ->int, :line 319, :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name ->long, :line 318, :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name batch, :line 420, :arglists ([n]), :doc "Returns a transducer that will return a sequence of row batches, where the batch\nsize is n.", :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name cast-with, :line 145, :arglists ([cast-fns] [cast-fns {:as opts, :keys [except-first exception-handler only]}]), :doc "Returns a transducer that casts the vals of each row according to `cast-fns`, which must either\nbe a map of `column-name -> casting-fn` or a single casting function to be applied towards all columns.\nOptions include:\n\n* `:except-first` - Leaves the first row unaltered; useful for preserving header row.\n* `:exception-handler` - If cast-fn raises an exception, this function will be called with args\n  `colname, value`, and the result used as the parse value.\n* `:only` - Only cast the specified column(s); can be either a single column name, or a vector of them.", :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name mappify, :line 21, :arglists ([] [{:as opts, :keys [keyify transform-header header], :or {keyify true}}]), :doc "Returns a transducer that transforms row vectors into maps, where keys are taken as the first row or as\nspecified via `:header` option.  Options include:\n\n* `:keyify` - bool; specify whether header/column names should be turned into keywords (default: `true`).\n* `:header` - specify the header to use for map keys, preventing first row of data from being consumed as header.\n* `:transform-header` - specify a transformation function for each header key (ignored if `:header` or `:keyify` is specified).", :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name process, :line 209, :arglists ([] [{:keys [mappify keyify header transform-header remove-comments comment-re comment-char structs cast-fns cast-exception-handler cast-only], :or {mappify true, keyify true, remove-comments true, comment-re #regex "^\\#"}, :as opts}]), :doc "Returns a transducers that composes the most frequently used input processing capabilities,\nand is controlled by an `opts` hash with opinionated defaults:\n\n* `:mappify` - bool; transform rows from vectors into maps using `mappify`.\n* `:keyify` - bool; specify whether header/column names should be turned into keywords (default: `true`).\n* `:transform-header` - specify a transformation function for each header key (ignored if `:header` or `:keyify` is specified).\n* `:header` - specify header to be used in mappify; as per `mappify`, first row will not be consumed as header\n* `:structs` - bool; use structify insead of mappify\n* `:remove-comments` - bool; remove comment lines, as specified by `:comment-re` or `:comment-char`. Also\n   removes empty lines. Defaults to `true`.\n* `:comment-re` - specify a regular expression to use for commenting out lines.\n* `:comment-char` - specify a comment character to use for filtering out comments; overrides comment-re.\n* `:cast-fns` - optional map of `colname | index -> cast-fn`; row maps will have the values as output by the\n   assigned `cast-fn`.\n* `:cast-exception-handler` - If cast-fn raises an exception, this function will be called with args\n  `colname, value`, and the result used as the parse value.\n* `:cast-only` - Only cast the specified column(s); can be either a single column name, or a vector of them.", :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name remove-comments, :line 107, :arglists ([] [{:as opts, :keys [comment-re comment-char]}]), :doc "Returns a transducer that removes rows starting with a comment character (by default, `#`).\nOperates by checking whether the first item of every row in the collection matches a comment pattern.\nAlso removes empty lines. Options include:\n\n* `:comment-re` - Specify a custom regular expression for determining which lines are commented out.\n* `:comment-char` - Checks for lines lines starting with this char.\n\nNote: this function only works (or makes sense) with rows that are vectors, and so should always be used\nbefore mappify.", :file "semantic_csv/transducers.cljc", :type :var, :members ()} {:name vectorize, :line 361, :arglists ([] [{:keys [header prepend-header format-header], :or {prepend-header true, format-header impl/stringify-keyword}}]), :doc "Returns a transducer that transforms maps into vectors. Options include:\n\n* `:header` - The header to be used. If not specified, this defaults to `(-> rows first keys)`. Only\n  values corresponding to the specified header will be included in the output, and will be included in the\n  order corresponding to this argument.\n* `:prepend-header` - Defaults to true, and controls whether the `:header` vector should be prepended\n  to the output sequence.\n* `:format-header` - If specified, this function will be called on each element of the `:header` vector, and\n  the result prepended to the output sequence. The default behaviour is to leave strings alone but stringify\n  keyword names such that the `:` is removed from their string representation. Passing a falsey value will\n  leave the header unaltered in the output.", :file "semantic_csv/transducers.cljc", :type :var, :members ()})}]}, :pom-str "<?xml version=\"1.0\" encoding=\"UTF-8\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>semantic-csv</groupId>\n  <artifactId>semantic-csv</artifactId>\n  <packaging>jar</packaging>\n  <version>0.2.1-alpha1</version>\n  <name>semantic-csv</name>\n  <description>A Clojure library with higher level CSV parsing functionality</description>\n  <url>http://github.com/metasoarous/semantic-csv</url>\n  <licenses>\n    <license>\n      <name>Eclipse Public License</name>\n      <url>http://www.eclipse.org/legal/epl-v10.html</url>\n    </license>\n  </licenses>\n  <scm>\n    <connection>scm:git:git://github.com/metasoarous/semantic-csv.git</connection>\n    <developerConnection>scm:git:ssh://git@github.com/metasoarous/semantic-csv.git</developerConnection>\n    <tag>4c56c5fdac71c6deb8f0b8f96a896bce95f996a7\n</tag>\n    <url>https://github.com/metasoarous/semantic-csv</url>\n  </scm>\n  <build>\n    <sourceDirectory>src</sourceDirectory>\n    <testSourceDirectory>test</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>resources</directory>\n      </testResource>\n    </testResources>\n    <directory>target</directory>\n    <outputDirectory>target/classes</outputDirectory>\n    <plugins/>\n  </build>\n  <repositories>\n    <repository>\n      <id>central</id>\n      <url>https://repo1.maven.org/maven2/</url>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n    <repository>\n      <id>clojars</id>\n      <url>https://clojars.org/repo/</url>\n      <snapshots>\n        <enabled>true</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n  </repositories>\n  <dependencyManagement>\n    <dependencies/>\n  </dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojure</artifactId>\n      <version>1.9.0-alpha14</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojurescript</artifactId>\n      <version>1.9.493</version>\n    </dependency>\n    <dependency>\n      <groupId>clojure-csv</groupId>\n      <artifactId>clojure-csv</artifactId>\n      <version>2.0.1</version>\n    </dependency>\n    <dependency>\n      <groupId>com.cemerick</groupId>\n      <artifactId>piggieback</artifactId>\n      <version>0.2.1</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n<!-- This file was autogenerated by Leiningen.\n  Please do not edit it directly; instead edit project.clj and regenerate it.\n  It should not be considered canonical data. For more information see\n  https://github.com/technomancy/leiningen -->\n"}