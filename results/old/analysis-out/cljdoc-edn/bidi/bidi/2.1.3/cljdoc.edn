{:group-id "bidi", :artifact-id "bidi", :version "2.1.3", :codox {"clj" [{:name bidi.verbose, :publics ({:name branch, :file "bidi/verbose.cljc", :line 8, :arglists ([fragment & children]), :type :var, :members ()} {:name leaf, :file "bidi/verbose.cljc", :line 5, :arglists ([fragment name]), :type :var, :members ()} {:name param, :file "bidi/verbose.cljc", :line 14, :arglists ([name]), :type :var, :members ()})} {:name bidi.bidi, :publics ({:name alts, :file "bidi/bidi.cljc", :line 492, :arglists ([& alts]), :type :var, :members ()} {:name compile-route, :file "bidi/bidi.cljc", :line 562, :arglists ([route]), :deprecated true, :type :var, :members ()} {:name handler, :file "bidi/bidi.cljc", :line 521, :arglists ([k handler] [handler]), :deprecated true, :type :var, :members ()} {:name just-path, :file "bidi/bidi.cljc", :line 187, :arglists ([path]), :type :var, :members ()} {:name match-beginning, :file "bidi/bidi.cljc", :line 203, :arglists ([regex-pattern env]), :doc "Match the beginning of the :remainder value in m. If matched, update\nthe :remainder value in m with the path that remains after matching.", :type :var, :members ()} {:name match-pair, :file "bidi/bidi.cljc", :line 194, :arglists ([[pattern matched] orig-env]), :doc "A pair contains a pattern to match (either fully or partially) and an\nexpression yielding a handler. The second parameter is a map\ncontaining state, including the remaining path.", :type :var, :members ()} {:name match-route, :file "bidi/bidi.cljc", :line 385, :arglists ([route path & {:as options}]), :doc "Given a route definition data structure and a path, return the\nhandler, if any, that matches the path.", :type :var, :members ()} {:name match-route*, :file "bidi/bidi.cljc", :line 380, :arglists ([route path options]), :type :var, :members ()} {:name Matched, :file "bidi/bidi.cljc", :line 183, :doc nil, :type :protocol, :members ({:name resolve-handler, :arglists ([_ m]), :doc nil, :type :var, :members ()} {:name unresolve-handler, :arglists ([_ m]), :doc nil, :type :var, :members ()})} {:name Matches, :file "bidi/bidi.cljc", :line 404, :doc nil, :type :protocol, :members ({:name matches, :arglists ([_]), :doc "A protocol used in the expansion of possible matches that the pattern can match. This is used to gather all possible routes using route-seq below.\n", :type :var, :members ()})} {:name ParameterEncoding, :file "bidi/bidi.cljc", :line 34, :doc nil, :type :protocol, :members ({:name encode-parameter, :arglists ([_]), :doc nil, :type :var, :members ()})} {:name path-for, :file "bidi/bidi.cljc", :line 391, :arglists ([route handler & {:as params}]), :doc "Given a route definition data structure, a handler and an option map, return a\npath that would route to the handler. The map must contain the values to any\nparameters required to create the path, and extra values are silently ignored.", :type :var, :members ()} {:name Pattern, :file "bidi/bidi.cljc", :line 176, :doc nil, :type :protocol, :members ({:name match-pattern, :arglists ([_ env]), :doc "Return a new state if this pattern matches the given state, or\nfalsy otherwise. If a new state is returned it will usually have the\nrest of the path to match in the :remainder entry.", :type :var, :members ()} {:name unmatch-pattern, :arglists ([_ m]), :doc nil, :type :var, :members ()})} {:name PatternSegment, :file "bidi/bidi.cljc", :line 71, :doc nil, :type :protocol, :members ({:name matches?, :arglists ([_ s]), :doc nil, :type :var, :members ()} {:name param-key, :arglists ([_]), :doc nil, :type :var, :members ()} {:name segment-regex-group, :arglists ([_]), :doc nil, :type :var, :members ()} {:name transform-param, :arglists ([_]), :doc nil, :type :var, :members ()} {:name unmatch-segment, :arglists ([_ params]), :doc nil, :type :var, :members ()})} {:name route-seq, :file "bidi/bidi.cljc", :line 424, :arglists ([[pattern matched] ctx] [route]), :type :var, :members ()} {:name RouteProvider, :file "bidi/bidi.cljc", :line 465, :doc nil, :type :protocol, :members ({:name routes, :arglists ([_]), :doc "Provide a bidi route structure. Returns a vector pair,\nthe first element is the pattern, the second element is the matched\nroute or routes.", :type :var, :members ()})} {:name routes-context, :file "bidi/bidi.cljc", :line 546, :arglists ([routes context]), :doc "Wrap a Matched such that a successful match will merge the given\ncontext with the match-context. The merge is such that where there\nis a conflict, the inner sub-tree overrides the outer container.", :type :var, :members ()} {:name RouteSeq, :file "bidi/bidi.cljc", :line 421, :doc nil, :type :protocol, :members ({:name gather, :arglists ([_ context]), :doc "Return a sequence of leaves\n", :type :var, :members ()})} {:name succeed, :file "bidi/bidi.cljc", :line 211, :arglists ([handler m]), :type :var, :members ()} {:name tag, :file "bidi/bidi.cljc", :line 509, :arglists ([matched tag]), :type :var, :members ()} {:name unmatch-pair, :file "bidi/bidi.cljc", :line 324, :arglists ([v m]), :type :var, :members ()} {:name url-decode, :file "bidi/bidi.cljc", :line 16, :arglists ([string] [string encoding]), :type :var, :members ()} {:name url-encode, :file "bidi/bidi.cljc", :line 8, :arglists ([string]), :type :var, :members ()} {:name uuid, :file "bidi/bidi.cljc", :line 22, :arglists ([s]), :doc "Function for creating a UUID of the appropriate type for the platform.\nNote that this function should _only_ be used in route patterns as, at least\nin the case of ClojureScript, it does not validate that the input string is\nactually a valid UUID (this is handled by the route matching logic).", :type :var, :members ()})} {:name bidi.ring, :publics ({:name archive, :file "bidi/ring.cljc", :line 179, :arglists ([options]), :type :var, :members ()} {:name files, :file "bidi/ring.cljc", :line 152, :arglists ([options]), :type :var, :members ()} {:name make-handler, :file "bidi/ring.cljc", :line 32, :arglists ([route handler-fn] [route]), :doc "Create a Ring handler from the route definition data\nstructure. Matches a handler from the uri in the request, and invokes\nit with the request as a parameter.", :type :var, :members ()} {:name redirect, :file "bidi/ring.cljc", :line 81, :arglists ([target]), :type :var, :members ()} {:name redirect-after-post, :file "bidi/ring.cljc", :line 85, :arglists ([target]), :type :var, :members ()} {:name resources, :file "bidi/ring.cljc", :line 107, :arglists ([options]), :type :var, :members ()} {:name resources-maybe, :file "bidi/ring.cljc", :line 133, :arglists ([options]), :type :var, :members ()} {:name Ring, :file "bidi/ring.cljc", :line 16, :doc nil, :type :protocol, :members ({:name request, :arglists ([_ req match-context]), :doc "Handle a Ring request, but optionally utilize any context that was\ncollected in the process of matching the handler.", :type :var, :members ()})} {:name wrap-middleware, :file "bidi/ring.cljc", :line 193, :arglists ([matched middleware]), :type :var, :members ()})} {:name bidi.vhosts, :publics ({:name coerce-to-vhost, :file "bidi/vhosts.clj", :line 27, :type :var, :members ()} {:name coerce-to-vhosts, :file "bidi/vhosts.clj", :line 38, :type :var, :members ()} {:name find-handler, :file "bidi/vhosts.clj", :line 157, :arglists ([vhosts-model req]), :type :var, :members ()} {:name host, :file "bidi/vhosts.clj", :line 94, :arglists ([req]), :doc "Get the real host from a request, taking into account reverse-proxy headers\n", :type :var, :members ()} {:name host-for, :file "bidi/vhosts.clj", :line 149, :type :var, :members ()} {:name href-for, :file "bidi/vhosts.clj", :line 151, :type :var, :members ()} {:name make-default-not-found-handler, :file "bidi/vhosts.clj", :line 185, :arglists ([vhosts-model]), :type :var, :members ()} {:name make-handler, :file "bidi/vhosts.clj", :line 193, :arglists ([vhosts-model] [vhosts-model handler-fn] [vhosts-model handler-fn not-found]), :type :var, :members ()} {:name path-for, :file "bidi/vhosts.clj", :line 148, :type :var, :members ()} {:name prioritize-vhosts, :file "bidi/vhosts.clj", :line 100, :arglists ([vhosts-model vhost]), :type :var, :members ()} {:name redirect, :file "bidi/vhosts.clj", :line 234, :arglists ([target & [opts]]), :type :var, :members ()} {:name relativize, :file "bidi/vhosts.clj", :line 75, :arglists ([from to]), :type :var, :members ()} {:name scheme, :file "bidi/vhosts.clj", :line 87, :arglists ([req]), :doc "Get the real scheme (as a keyword) from a request, taking into\naccount reverse-proxy headers", :type :var, :members ()} {:name scheme-for, :file "bidi/vhosts.clj", :line 150, :type :var, :members ()} {:name uri->host, :file "bidi/vhosts.clj", :line 22, :arglists ([uri]), :type :var, :members ()} {:name uri-for, :file "bidi/vhosts.clj", :line 155, :deprecated true, :type :var, :members ()} {:name uri-info, :file "bidi/vhosts.clj", :line 104, :arglists ([prioritized-vhosts handler & [{:keys [request vhost route-params query-params prefer fragment], :or {prefer :local}, :as options}]]), :doc "Return URI info as a map.\n", :type :var, :members ()} {:name VHost, :file "bidi/vhosts.clj", :line 13, :doc "\n", :type :var, :members ()} {:name vhosts->roots, :file "bidi/vhosts.clj", :line 175, :arglists ([vhosts request]), :type :var, :members ()} {:name vhosts-model, :file "bidi/vhosts.clj", :line 53, :arglists ([& vhosts-with-routes]), :type :var, :members ()} {:name VHostWithRoutes, :file "bidi/vhosts.clj", :line 18, :doc "\n", :type :var, :members ()})} {:name bidi.schema, :publics ({:name AlternatesSet, :file "bidi/schema.cljc", :line 31, :doc "\n", :type :var, :members ()} {:name DeprecatedAlternates, :file "bidi/schema.cljc", :line 34, :doc "\n", :type :var, :members ()} {:name GeneralGuard, :file "bidi/schema.cljc", :line 23, :type :var, :members ()} {:name Matched, :file "bidi/schema.cljc", :line 49, :type :var, :members ()} {:name MethodGuard, :file "bidi/schema.cljc", :line 20, :type :var, :members ()} {:name Path, :file "bidi/schema.cljc", :line 9, :type :var, :members ()} {:name Pattern, :file "bidi/schema.cljc", :line 38, :type :var, :members ()} {:name PatternSegment, :file "bidi/schema.cljc", :line 14, :type :var, :members ()} {:name RoutePair, :file "bidi/schema.cljc", :line 59, :type :var, :members ()} {:name SegmentedPattern, :file "bidi/schema.cljc", :line 26, :doc "\n", :type :var, :members ()} {:name valid-qualifier-function?, :file "bidi/schema.cljc", :line 11, :arglists ([qual]), :type :var, :members ()})}], "cljs" [{:name bidi.bidi, :doc nil, :publics ({:name Alternates, :line 481, :file "bidi/bidi.cljc", :type :var, :members ()} {:name alts, :line 492, :arglists ([& alts]), :file "bidi/bidi.cljc", :type :var, :members ()} {:name compile-route, :line 562, :arglists ([route]), :deprecated true, :file "bidi/bidi.cljc", :type :var, :members ()} {:name handler, :line 521, :arglists ([k handler] [handler]), :deprecated true, :file "bidi/bidi.cljc", :type :var, :members ()} {:name IdentifiableHandler, :line 512, :file "bidi/bidi.cljc", :type :var, :members ()} {:name just-path, :line 187, :arglists ([path]), :file "bidi/bidi.cljc", :type :var, :members ()} {:name match-beginning, :line 203, :arglists ([regex-pattern env]), :doc "Match the beginning of the :remainder value in m. If matched, update\nthe :remainder value in m with the path that remains after matching.", :file "bidi/bidi.cljc", :type :var, :members ()} {:name match-pair, :line 194, :arglists ([[pattern matched] orig-env]), :doc "A pair contains a pattern to match (either fully or partially) and an\nexpression yielding a handler. The second parameter is a map\ncontaining state, including the remaining path.", :file "bidi/bidi.cljc", :type :var, :members ()} {:name match-route, :line 385, :arglists ([route path & {:as options}]), :doc "Given a route definition data structure and a path, return the\nhandler, if any, that matches the path.", :file "bidi/bidi.cljc", :type :var, :members ()} {:name match-route*, :line 380, :arglists ([route path options]), :file "bidi/bidi.cljc", :type :var, :members ()} {:name Matched, :line 183, :doc nil, :file "bidi/bidi.cljc", :type :protocol, :members ({:name resolve-handler, :line 183, :arglists ([_ m]), :doc nil, :file "bidi/bidi.cljc", :type :var, :members ()} {:name unresolve-handler, :line 183, :arglists ([_ m]), :doc nil, :file "bidi/bidi.cljc", :type :var, :members ()})} {:name Matches, :line 404, :doc nil, :file "bidi/bidi.cljc", :type :protocol, :members ({:name matches, :line 404, :arglists ([_]), :doc "A protocol used in the expansion of possible matches that the pattern can match. This is used to gather all possible routes using route-seq below.\n", :file "bidi/bidi.cljc", :type :var, :members ()})} {:name ParameterEncoding, :line 34, :doc nil, :file "bidi/bidi.cljc", :type :protocol, :members ({:name encode-parameter, :line 34, :arglists ([_]), :doc nil, :file "bidi/bidi.cljc", :type :var, :members ()})} {:name path-for, :line 391, :arglists ([route handler & {:as params}]), :doc "Given a route definition data structure, a handler and an option map, return a\npath that would route to the handler. The map must contain the values to any\nparameters required to create the path, and extra values are silently ignored.", :file "bidi/bidi.cljc", :type :var, :members ()} {:name Pattern, :line 176, :doc nil, :file "bidi/bidi.cljc", :type :protocol, :members ({:name match-pattern, :line 176, :arglists ([_ env]), :doc "Return a new state if this pattern matches the given state, or\nfalsy otherwise. If a new state is returned it will usually have the\nrest of the path to match in the :remainder entry.", :file "bidi/bidi.cljc", :type :var, :members ()} {:name unmatch-pattern, :line 176, :arglists ([_ m]), :doc nil, :file "bidi/bidi.cljc", :type :var, :members ()})} {:name PatternSegment, :line 71, :doc nil, :file "bidi/bidi.cljc", :type :protocol, :members ({:name transform-param, :line 71, :arglists ([_]), :doc nil, :file "bidi/bidi.cljc", :type :var, :members ()} {:name unmatch-segment, :line 71, :arglists ([_ params]), :doc nil, :file "bidi/bidi.cljc", :type :var, :members ()} {:name segment-regex-group, :line 71, :arglists ([_]), :doc nil, :file "bidi/bidi.cljc", :type :var, :members ()} {:name param-key, :line 71, :arglists ([_]), :doc nil, :file "bidi/bidi.cljc", :type :var, :members ()} {:name matches?, :line 71, :arglists ([_ s]), :doc nil, :file "bidi/bidi.cljc", :type :var, :members ()})} {:name Route, :line 419, :file "bidi/bidi.cljc", :type :var, :members ()} {:name route-seq, :line 424, :arglists ([[pattern matched] ctx] [route]), :file "bidi/bidi.cljc", :type :var, :members ()} {:name RouteProvider, :line 465, :doc nil, :file "bidi/bidi.cljc", :type :protocol, :members ({:name routes, :line 465, :arglists ([_]), :doc "Provide a bidi route structure. Returns a vector pair,\nthe first element is the pattern, the second element is the matched\nroute or routes.", :file "bidi/bidi.cljc", :type :var, :members ()})} {:name routes-context, :line 546, :arglists ([routes context]), :doc "Wrap a Matched such that a successful match will merge the given\ncontext with the match-context. The merge is such that where there\nis a conflict, the inner sub-tree overrides the outer container.", :file "bidi/bidi.cljc", :type :var, :members ()} {:name RoutesContext, :line 533, :file "bidi/bidi.cljc", :type :var, :members ()} {:name RouteSeq, :line 421, :doc nil, :file "bidi/bidi.cljc", :type :protocol, :members ({:name gather, :line 421, :arglists ([_ context]), :doc "Return a sequence of leaves\n", :file "bidi/bidi.cljc", :type :var, :members ()})} {:name succeed, :line 211, :arglists ([handler m]), :file "bidi/bidi.cljc", :type :var, :members ()} {:name tag, :line 509, :arglists ([matched tag]), :file "bidi/bidi.cljc", :type :var, :members ()} {:name TaggedMatch, :line 498, :file "bidi/bidi.cljc", :type :var, :members ()} {:name unmatch-pair, :line 324, :arglists ([v m]), :file "bidi/bidi.cljc", :type :var, :members ()} {:name url-decode, :line 16, :arglists ([string]), :file "bidi/bidi.cljc", :type :var, :members ()} {:name url-encode, :line 8, :arglists ([string]), :file "bidi/bidi.cljc", :type :var, :members ()} {:name uuid, :line 22, :arglists ([s]), :doc "Function for creating a UUID of the appropriate type for the platform.\nNote that this function should _only_ be used in route patterns as, at least\nin the case of ClojureScript, it does not validate that the input string is\nactually a valid UUID (this is handled by the route matching logic).", :file "bidi/bidi.cljc", :type :var, :members ()})} {:name bidi.ring, :doc nil, :publics ({:name make-handler, :line 32, :arglists ([route handler-fn] [route]), :doc "Create a Ring handler from the route definition data\nstructure. Matches a handler from the uri in the request, and invokes\nit with the request as a parameter.", :file "bidi/ring.cljc", :type :var, :members ()} {:name Ring, :line 16, :doc nil, :file "bidi/ring.cljc", :type :protocol, :members ({:name request, :line 16, :arglists ([_ req match-context]), :doc "Handle a Ring request, but optionally utilize any context that was\ncollected in the process of matching the handler.", :file "bidi/ring.cljc", :type :var, :members ()})})} {:name bidi.router, :doc nil, :publics ({:name Router, :line 8, :doc nil, :file "bidi/router.cljs", :type :protocol, :members ({:name set-location!, :line 8, :arglists ([_ location]), :doc nil, :file "bidi/router.cljs", :type :var, :members ()} {:name replace-location!, :line 8, :arglists ([_ location]), :doc nil, :file "bidi/router.cljs", :type :var, :members ()})} {:name start-router!, :line 12, :arglists ([routes {:keys [on-navigate default-location], :or {on-navigate (constantly nil)}}]), :doc "Starts up a Bidi router based on Google Closure's 'History'\n\nTypes:\n\n  Location :- {:handler ...\n               :route-params {...}}\n\nParameters:\n\n  routes :- a Bidi route structure\n  on-navigate :- 0-arg function, accepting a Location\n  default-location :- Location to default to if the current token doesn't match a route\n\nReturns :- Router\n\nExample usage:\n\n  (require '[bidi.router :as br])\n\n  (let [!location (atom nil)\n        router (br/start-router! [\"\" {\"/\" ::home-page\n                                        \"/page2\" ::page2}]\n                                 {:on-navigate (fn [location]\n                                                 (reset! !location location))\n                                  :default-location {:handler ::home-page}})]\n\n    ...\n\n    (br/set-location! router {:handler ::page2}))", :file "bidi/router.cljs", :type :var, :members ()})} {:name bidi.schema, :doc nil, :publics ({:name AlternatesSet, :line 31, :doc "\n", :file "bidi/schema.cljc", :type :var, :members ()} {:name DeprecatedAlternates, :line 34, :doc "\n", :file "bidi/schema.cljc", :type :var, :members ()} {:name GeneralGuard, :line 23, :file "bidi/schema.cljc", :type :var, :members ()} {:name Matched, :line 49, :file "bidi/schema.cljc", :type :var, :members ()} {:name MethodGuard, :line 20, :file "bidi/schema.cljc", :type :var, :members ()} {:name Path, :line 9, :file "bidi/schema.cljc", :type :var, :members ()} {:name Pattern, :line 38, :file "bidi/schema.cljc", :type :var, :members ()} {:name PatternSegment, :line 14, :file "bidi/schema.cljc", :type :var, :members ()} {:name RoutePair, :line 59, :file "bidi/schema.cljc", :type :var, :members ()} {:name SegmentedPattern, :line 26, :doc "\n", :file "bidi/schema.cljc", :type :var, :members ()} {:name valid-qualifier-function?, :line 11, :arglists ([qual]), :file "bidi/schema.cljc", :type :var, :members ()})} {:name bidi.verbose, :doc nil, :publics ({:name branch, :line 8, :arglists ([fragment & children]), :file "bidi/verbose.cljc", :type :var, :members ()} {:name leaf, :line 5, :arglists ([fragment name]), :file "bidi/verbose.cljc", :type :var, :members ()} {:name param, :line 14, :arglists ([name]), :file "bidi/verbose.cljc", :type :var, :members ()})}]}, :pom-str "<?xml version=\"1.0\" encoding=\"UTF-8\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>bidi</groupId>\n  <artifactId>bidi</artifactId>\n  <packaging>jar</packaging>\n  <version>2.1.3</version>\n  <name>bidi</name>\n  <description>Bidirectional URI routing</description>\n  <url>https://github.com/juxt/bidi</url>\n  <licenses>\n    <license>\n      <name>The MIT License</name>\n      <url>http://opensource.org/licenses/MIT</url>\n    </license>\n  </licenses>\n  <scm>\n    <url>https://github.com/juxt/bidi</url>\n    <connection>scm:git:git://github.com/juxt/bidi.git</connection>\n    <developerConnection>scm:git:ssh://git@github.com/juxt/bidi.git</developerConnection>\n    <tag>d1bfcc9c4fe247b8ada19cd7ee25acd81dd93f26</tag>\n  </scm>\n  <build>\n    <sourceDirectory>src</sourceDirectory>\n    <testSourceDirectory>test</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>test-resources</directory>\n      </testResource>\n      <testResource>\n        <directory>resources</directory>\n      </testResource>\n    </testResources>\n    <directory>target</directory>\n    <outputDirectory>target/classes</outputDirectory>\n    <plugins/>\n  </build>\n  <repositories>\n    <repository>\n      <id>central</id>\n      <url>https://repo1.maven.org/maven2/</url>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n    <repository>\n      <id>clojars</id>\n      <url>https://repo.clojars.org/</url>\n      <snapshots>\n        <enabled>true</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n  </repositories>\n  <dependencyManagement>\n    <dependencies/>\n  </dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>prismatic</groupId>\n      <artifactId>schema</artifactId>\n      <version>1.1.3</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n    </dependency>\n    <dependency>\n      <groupId>ring</groupId>\n      <artifactId>ring-core</artifactId>\n      <version>1.5.0</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n        <exclusion>\n          <artifactId>clojure</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojure</artifactId>\n      <version>1.8.0</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojurescript</artifactId>\n      <version>1.9.293</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>tools.reader</artifactId>\n      <version>1.0.0-beta4</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>ring</groupId>\n      <artifactId>ring-mock</artifactId>\n      <version>0.3.0</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>compojure</groupId>\n      <artifactId>compojure</artifactId>\n      <version>1.6.0-beta2</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>criterium</groupId>\n      <artifactId>criterium</artifactId>\n      <version>0.4.3</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.mozilla</groupId>\n      <artifactId>rhino</artifactId>\n      <version>1.7.7.1</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n<!-- This file was autogenerated by Leiningen.\n  Please do not edit it directly; instead edit project.clj and regenerate it.\n  It should not be considered canonical data. For more information see\n  https://github.com/technomancy/leiningen -->\n"}